
1. CREAR PROYECTO CON VITE:

  Paso a Paso                                               npm create vite@latest

  Paso	MÃ©todo Profe (manual)	                              Tu MÃ©todo (automÃ¡tico con Vite)
  Iniciar proyecto Node	npm init -y	                        âœ… Lo hizo por ti
  Instalar Vite	npm install -D vite	                        âœ… Lo hizo por ti
  Crear script "dev"	Editar package.json	                  âœ… Ya viene creado
  Estructura base	Crear a mano /src, index.html, etc.     	âœ… Ya viene creada y lista
  Ejecutar servidor	npm run dev	                            âœ… Igualito

// â€œInicialicÃ© el proyecto con Vite usando el comando oficial npm create vite@latest que genera automÃ¡ticamente la estructura base, Inicializa el proyecto con Node,
Genera package.json automÃ¡ticamente, instala Vite y configura los scripts necesarios. Es una forma moderna y eficiente aprobada por la documentaciÃ³n oficial.â€


| Â¿QuÃ© haces con Node?                         | Â¿CÃ³mo?           |
| -------------------------------------------- | ---------------- |
| âš™ï¸ Administrar dependencias                  | `npm install`    |
| ğŸš€ Levantar el servidor de desarrollo (Vite) | `npm run dev`    |
| ğŸ“¦ Usar herramientas modernas como Vite      | `vite.config.js` |
| ğŸ§ª Simular una API con JSON Server           | `json-server`    |



Elemento	                Â¿QuÃ© hace?	                                              Â¿Lo genera Vite?	            Â¿Sirve paraâ€¦?
package.json	            Configura todo el proyecto, scripts, dependencias	        âœ… SÃ­	                       Levantar Vite y scripts
db.json	                  Mini base de datos falsa para practicar con json-server	  âŒ No	                       Simular una API REST
scripts en package.json	  Comandos como npm run dev, npm run json:server	          âœ… Lo agregas tÃº o Vite	     Automatizar tareas


ğŸ“¦ /mi-sistema-vite
â”œâ”€â”€ ğŸ“ public
â”‚   â””â”€â”€ logo.png              â† ImÃ¡genes accesibles por ruta absoluta
â”œâ”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ assets              â† CSS, imÃ¡genes internas, Ã­conos, etc.
â”‚   â”‚   â”œâ”€â”€ styles.css
â”‚   â”œâ”€â”€ ğŸ“ components          â† Reutilizables (header, sidebar, modal)
â”‚   â”‚   â”œâ”€â”€ header.js
â”‚   â”‚   â”œâ”€â”€ sidebar.js
â”‚   â”‚   â””â”€â”€ modal.js
â”‚   â”œâ”€â”€ ğŸ“ pages               â† "Vistas": login, dashboard, home, etc.
â”‚   â”‚   â”œâ”€â”€ login.js
â”‚   â”‚   â”œâ”€â”€ register.js
â”‚   â”‚   â”œâ”€â”€ dashboard.js
â”‚   â”‚   â”œâ”€â”€ public.js         â† Vista pÃºblica (visitante)
â”‚   â”œâ”€â”€ ğŸ“ services            â† ComunicaciÃ³n con la API (CRUD)
â”‚   â”‚   â”œâ”€â”€ auth.js           â† login, registro, localStorage
â”‚   â”‚   â”œâ”€â”€ users.js          â† GET, POST, PUT, DELETE users
â”‚   â”‚   â”œâ”€â”€ courses.js        â† CRUD cursos
â”‚   â”‚   â”œâ”€â”€ enrollments.js    â† inscripciones
â”‚   â”œâ”€â”€ ğŸ“ utils               â† Helpers: validaciones, formateo
â”‚   â”‚   â”œâ”€â”€ validation.js
â”‚   â”‚   â”œâ”€â”€ storage.js        â† getUserStorage, saveSession, etc.
â”‚   â””â”€â”€ main.js               â† Punto de entrada: enrutamiento SPA
â”œâ”€â”€ ğŸ“„ index.html             â† HTML Ãºnico de la SPA
â”œâ”€â”€ ğŸ“„ db.json                â† Base de datos falsa para JSON Server
â”œâ”€â”€ ğŸ“„ package.json


| Vista                 | Ruta esperada       | Visible para...           | Contenido                      |
| --------------------- | ------------------- | ------------------------- | ------------------------------ |
| `login`               | `/login`            | Todos                     | Formulario para iniciar sesiÃ³n |
| `register`            | `/register`         | Todos                     | Formulario de registro         |
| `public` (visitante)  | `/` o `/home`       | No logueados              | Lista pÃºblica de cursos        |
| `dashboard`           | `/admin` o `/panel` | Solo admin                | Panel de control, gestiÃ³n CRUD |
| `userHome` (opcional) | `/mis-cursos`       | Usuarios logueados (user) | Cursos inscritos               |


  2. En el main.js cargo las vistas correspondientes:
        import { renderLogin } from './pages/login.js';
        import { renderDashboard } from './pages/dashboard.js';
        import { renderPublic } from './pages/public.js';
        import { getUserStorage } from './utils/storage.js'
        //Estos son import estamos trayendo funciones que estÃ¡n definidas en otros archivos, para usarlas aquÃ­ en main.js.

      | LÃ­nea             | Â¿QuÃ© trae?                                                   | Â¿Desde dÃ³nde?            |
      | ----------------- | ------------------------------------------------------------ | ------------------------ |
      | `renderLogin`     | FunciÃ³n que dibuja o construye el login                      | `src/pages/login.js`     |
      | `renderDashboard` | FunciÃ³n que construye el panel admin                         | `src/pages/dashboard.js` |
      | `renderPublic`    | FunciÃ³n que muestra la vista pÃºblica                         | `src/pages/public.js`    |
      | `getUserStorage`  | FunciÃ³n que revisa si hay usuario guardado en `localStorage` | `src/utils/storage.js`   |


=====>
            function router() {
              const user = getUserStorage(); 
              if (!user) {  
                renderPublic(app);
              } else if (user.role === 'admin') {
                renderDashboard(app); 
              } else {
                renderPublic(app); //â˜¢ï¸(Cambiar por vista de usuario)
              }
            }

            router();


  2.1 "const app = document.getElementById('app');"

        Â¿QuÃ© hace esto?
        Toma el elemento con id="app" del HTML (el div donde vamos a renderizar todo).
        Lo guarda en la constante app para poder usarlo mÃ¡s adelante.


  2.2  "const user = getUserStorage(); "

        Esa funciÃ³n revisa si hay un usuario guardado en localStorage
        i sÃ­ hay, lo guarda en la variable user.
        Si el usuario ya iniciÃ³ sesiÃ³n antes, sus datos estÃ¡n guardados y user tendrÃ¡ algo como:
          {
          id: 1,
          name: "Vane",
          role: "admin"
        }

  2.3 " if (!user) {  
                renderPublic(app); "

      â“Â¿QuÃ© significa if (!user)?
        Es una forma de preguntar: â€œÂ¿NO hay usuario?â€
        !user se lee como â€œno existe un usuarioâ€
        Si es cierto, entonces mostramos la vista pÃºblica llamando a renderPublic(app);
        O sea: si nadie ha iniciado sesiÃ³n, mostramos la pantalla pÃºblica.

  2.4 "  } else if (user.role === 'admin') {
      renderDashboard(app); "

        ğŸ§‘â€ğŸ’¼ Â¿QuÃ© hace esto?
        Si sÃ­ hay un usuario, entonces revisamos su role
        Si su rol es 'admin', mostramos el panel de administraciÃ³n     


  2.5   "} else {
        renderUserHome(app); // Vista de usuario
      }"

        Â¿QuÃ© pasa aquÃ­?
        Si el usuario existe pero no es admin, mostramos Vista de usuario

  2.6   router(); // ejecutamos al inicio

  Resumen visual

        Si NO hay usuario guardado en localStorage:
            â†’ Mostrar vista pÃºblica (renderPublic)

        Si hay usuario Y su rol es "admin":
            â†’ Mostrar vista admin (renderDashboard)

        Si hay usuario pero NO es admin:
            â†’ Mostrar Vista de usuario


âœ¨ Â¿CÃ³mo se debe nombrar una funciÃ³n en JavaScript?

ğŸ”¸ El nombre debe indicar lo que hace la funciÃ³n.
ğŸ”¸ No importa cÃ³mo la llames, lo importante es que tenga sentido.
ğŸ”¤ Ejemplos comunes segÃºn lo que hace la funciÃ³n:          

| Nombre      | CuÃ¡ndo se usa                                      | Ejemplo                 |
| ----------- | -------------------------------------------------- | ----------------------- |
| `renderX()` | Si la funciÃ³n **muestra algo en pantalla** (HTML)  | `renderLogin(app)`      |
| `getX()`    | Si la funciÃ³n **trae algo** (datos, usuarios, etc) | `getCourses()`          |
| `saveX()`   | Si la funciÃ³n **guarda** algo                      | `saveUserStorage(user)` |
| `createX()` | Si la funciÃ³n **crea un nuevo recurso**            | `createCourse()`        |
| `updateX()` | Si la funciÃ³n **edita o actualiza** algo           | `updateUser(id, data)`  |
| `deleteX()` | Si **elimina** un recurso                          | `deleteCourse(id)`      |

âœ… Entonces...
Si tu funciÃ³n carga una vista o contenido HTML, el nombre ideal serÃ­a:

renderLogin()
renderDashboard()
renderUserHome()
renderPublic()

Si solo trae datos (como fetch a json-server), serÃ­a:

getUsers()
getCourses()

Si guarda algo en localStorage:

saveUserStorage()


PASO 3
//funciÃ³n en public.js (src/pages/public.js)

    ğŸ“LÃ­nea 1
      export function renderPublic(app) {
          ğŸ” ExplicaciÃ³n:

    export: significa que esta funciÃ³n puede ser usada en otros archivos (como en main.js).
    function: estamos declarando una funciÃ³n.
    renderPublic: es el nombre de la funciÃ³n. Elegimos ese nombre porque esta funciÃ³n va a renderizar la vista pÃºblica (cuando nadie estÃ¡ logueado).
    (app): es un parÃ¡metro. Es el div donde vamos a insertar el contenido HTML dinÃ¡mico, normalmente el div con id="app" que ya seleccionamos en main.js.

    ğŸ“LÃ­nea 2

            app.innerHTML = ` 
            <section>
              <h2>Bienvenido a la Plataforma Educativa</h2>
              <p>Por favor, inicia sesiÃ³n o regÃ­strate para acceder a los cursos.</p>
              <button id="login-btn">Iniciar SesiÃ³n</button>
              <button id="register-btn">Registrarse</button>
            </section>
          `;
        // Ahora sÃ­ existen los botones en el DOM, podemos acceder a ellos
          document.getElementById('login-btn').addEventListener('click',()=> {
              console.log('Click en login');
              renderLogin(app);
          });

          document.getElementById('register-btn').addEventListener('click',()=> {
              console.log('Click en register');
              //renderRegister(app); <= Activarlo
          });
        }


  ğŸ” ExplicaciÃ³n:
      app: es el parÃ¡metro recibido (el contenedor principal de la app).
      .innerHTML: es una propiedad de JavaScript que permite escribir contenido HTML dentro de ese contenedor.
      `= ``: le estamos diciendo que vamos a escribir un bloque de HTML usando backticks (``) para usar template strings.


PASO4 
    // src/pages/login.js

      export function renderLogin(app) {
        app.innerHTML = `
          <section class="login-section">
            <h2>Iniciar SesiÃ³n</h2>
            <form id="login-form">
              <label for="email">Correo:</label>
              <input type="email" id="email" name="email" required />

              <label for="password">ContraseÃ±a:</label>
              <input type="password" id="password" name="password" required />

              <button type="submit">Ingresar</button>
            </form>
            <button id="back-btn">â† Volver</button>
          </section>
        `;

        // Escuchar envÃ­o del formulario
        document.getElementById('login-form').addEventListener('submit', (e) => {
          e.preventDefault();
          console.log('Login enviado');
          // AquÃ­ luego haremos la lÃ³gica de login con json-server
        });

        // Volver a la vista pÃºblica
        document.getElementById('back-btn').addEventListener('click', () => {
          window.location.hash = '#/';
        });
      }

    ğŸ§  ExplicaciÃ³n palabra por palabra (como te gusta ğŸ’›):
    export function renderLogin(app) â†’ Exportamos esta funciÃ³n para que pueda ser usada en main.js.
    app.innerHTML = â†’ Reemplaza todo el contenido del div id="app" con el formulario.
    <form id="login-form"> â†’ Es el formulario para ingresar correo y contraseÃ±a.
    e.preventDefault() â†’ Evita que el formulario recargue la pÃ¡gina al enviar.
    console.log('Login enviado') â†’ Por ahora, solo probamos que todo funcione.
    window.location.hash = '#/' â†’ Esto es para navegar de regreso a la vista pÃºblica como si fuera una SPA.


  PASO5
  âœ… Paso 1: Revisar tu db.json

        AsegÃºrate de tener algo asÃ­ (puedes agregarlo si no lo tienes):

        {
          "users": [
            {
              "id": 1,
              "name": "Admin",
              "email": "admin@admin.com",
              "password": "admin123",
              "role": "admin"
            },
            {
              "id": 2,
              "name": "Vanecita",
              "email": "vane@user.com",
              "password": "1234",
              "role": "user"
            }
          ]
        }

        Con eso tenemos un admin y un usuario normal para probar ğŸ”


PASO 6  
        En services guardamos todos los archivos que "hablan" con el servidor o con una API externa.
        Como auth.js se encarga de conectarse con JSON Server para verificar usuarios, va ahÃ­.
        ğŸ“ UbicaciÃ³n:
          spa-system/
            â””â”€â”€ src/
                â””â”€â”€ services/
                      â””â”€â”€ auth.js


        const API_URL = 'http://localhost:3000/users'; //endpoint de usuarios

        export async function loginUser(email, password) {
            try {
                const res = await fetch (`${API_URL}?email=${email}&password=${password}`);
                const users = await res.json();

                //Si encontrÃ³ un usuario que coincida con email y password
                if (users.length > 0){
                    return users[0]; // Usuario encontrado
                } else {
                    return null; //Usuario no existe
                } 
            } catch(error) {
                console.log('Error en loginUser', error);
                return null;
            }
        };

ğŸ” auth.js explicado palabra por palabra
const API_URL = 'http://localhost:3000/users';

    ğŸ”¸ const: es una constante, un valor que no va a cambiar.
    ğŸ”¸ API_URL: le damos un nombre claro â†’ es la URL de la base de datos db.json.
    ğŸ”¸ 'http://localhost:3000/users':

        localhost:3000 â†’ Es donde se levanta JSON Server.
        /users â†’ es la colecciÃ³n de usuarios dentro del db.json.
      ğŸ§  Esto es como decir: â€œMi base de datos vive en esta direcciÃ³nâ€

export async function loginUser(email, password) {
    ğŸ”¸ export: permite que esta funciÃ³n se pueda usar en otros archivos (como login.js).
    ğŸ”¸ async: indica que esta funciÃ³n es asÃ­ncrona, o sea, espera datos del servidor (porque fetch es asÃ­ncrono).
    ğŸ”¸ function loginUser(...): estamos creando una funciÃ³n llamada loginUser.
    ğŸ”¸ (email, password): son los datos que el usuario escribe en el formulario, y los pasamos para buscarlos en la base de datos.

try {
      const res = await fetch(`${API_URL}?email=${email}&password=${password}`);

    ğŸ”¸ try { ... }: bloque que intenta ejecutar cÃ³digo, por si hay errores.
    ğŸ”¸ await fetch(...): usamos fetch para ir a buscar los datos.
    ğŸ”¸ `${API_URL}?email=${email}&password=${password}`:
    Esto genera una URL como:

    http://localhost:3000/users?email=admin@admin.com&password=admin123

    ğŸ” Esa URL busca usuarios que tengan ese email y esa contraseÃ±a exactos.
    
const users = await res.json();
    ğŸ”¸ res: es la respuesta que da el servidor.
    ğŸ”¸ .json(): convertimos esa respuesta a formato JSON para poder trabajar con los datos en JS.
    ğŸ”¸ const users: lo que nos llega del servidor lo guardamos en esta variable.

  if (users.length > 0) {
    return users[0];
  } else {
    return null;
  }
    ğŸ”¸ if (users.length > 0): Si encontrÃ³ al menos un usuario con ese correo y contraseÃ±a...
    ğŸ”¸ return users[0]: devuelve el primer usuario encontrado (siempre debe ser solo uno).
    ğŸ”¸ else return null: si no encuentra nada, devuelve null â†’ es como decir â€œUsuario incorrectoâ€.

} catch (error) {
  console.error('Error en loginUser:', error);
  return null;
}

    ğŸ”¸ catch: si algo falla, entra aquÃ­ (por ejemplo, si no hay internet o el server no responde).
    ğŸ”¸ console.error(...): muestra el error en la consola para que podamos ver quÃ© pasÃ³.
    ğŸ”¸ return null: si hay error, tambiÃ©n devolvemos null para que el programa no se rompa.

const email = document.getElementById('email').value;
    const password = document.getElementById('password').value;

    const user = await loginUser(email, password);

    if (user) {
      localStorage.setItem('loggedUser', JSON.stringify(user));
      window.location.hash = ''; // Redirige a la vista segÃºn su rol
    } else {
      alert('Correoo o contraseÃ±a incorrectos');
    }
  });

        âœ¨ ExplicaciÃ³n palabra por palabra:
        localStorage.setItem('loggedUser', JSON.stringify(user))
        ğŸ”¹ localStorage: Es un almacenamiento local del navegador.
        ğŸ”¹ .setItem(clave, valor): Guarda un valor con una clave, como una cajita.

        âœ… "loggedUser": Es el nombre que usamos para guardar al usuario (puedes llamarlo como quieras, pero debe ser el mismo nombre para leerlo despuÃ©s).

        âœ… JSON.stringify(user): Convierte el objeto usuario a texto plano.
        Porque localStorage solo guarda texto. Luego lo leeremos con JSON.parse().


âœ… 1. Funciones normales (declaradas)
AquÃ­ el async va antes de la palabra function:

      async function nombreFuncion() {
        const respuesta = await fetch('https://api.com');
      }
ğŸ“Œ Estructura completa:

      [async] [function] [nombre]() {
        // cÃ³digo
      }

âœ… 2. Funciones anÃ³nimas o funciones flecha (arrow functions)

      AquÃ­ el async va antes de los parÃ©ntesis ( ) => {}
      O sea, antes de la funciÃ³n misma, como si envolvieras todo:

      const miFuncion = async () => {
        const datos = await fetch('...');
      }

  ğŸ“Œ O si es dentro de un addEventListener, como tÃº usas:

        boton.addEventListener('click', async (e) => {
          e.preventDefault();
          const datos = await fetch('...');
        });
ğŸ§  Es decir: async siempre se pone justo antes de la funciÃ³n completa, sea normal o flecha.

â— NO vÃ¡lido:
Esto no funciona (mal puesto el async):
        // âŒ INCORRECTO: esto lanza error
        (e) => async {
          const datos = await fetch(...);
        }

Ejemplo comparativo:

        | Tipo de funciÃ³n       | Forma correcta                                    |
        | --------------------- | ------------------------------------------------- |
        | Declarada tradicional | `async function cargarDatos() { ... }`            |
        | FunciÃ³n flecha        | `const cargarDatos = async () => { ... }`         |
        | En addEventListener   | `addEventListener('click', async (e) => { ... })` |

ğŸ’¡ BONUS: Â¿Por quÃ© cambia?
Porque function tiene su propia palabra clave.
En cambio () => {} es una expresiÃ³n (una constante que guarda una funciÃ³n),
asÃ­ que async tiene que ir antes de toda la expresiÃ³n, no dentro

